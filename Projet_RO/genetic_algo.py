from mapfunctions import*
from utils import*
from evaluation import*
from generator import*


def generate_population(Map, cost_map, pop_size, budget):
    population = []
    while len(population) < pop_size:
        Map_pop = np.zeros((len(Map), len(Map[0])))
        sum_cost = 0
        while sum_cost <= budget:

            j, k = np.random.randint(0, Map.shape[0]), np.random.randint(0, Map.shape[1])
            
            if Map[j, k] == 1 and sum_cost + cost_map[j, k] <= budget:
                Map_pop[j, k] = 2
                sum_cost += cost_map[j, k]
            elif sum_cost + cost_map[j, k] >= budget: 
                break

        population.append(Map_pop)
    
    return population


def tournament_selection(population, fitness_values,max_tournament_size,  min_tournament_size = 1):
    """
    Selects individuals from the population using tournament selection.
    The size of the tournament is randomly selected between min_tournament_size and max_tournament_size.

    Parameters:
        population (list): A list of individuals.
        fitness_values (list): A list of fitness values, one for each individual in the population.
        min_tournament_size (int): The minimum number of individuals to consider in each tournament.
        max_tournament_size (int): The maximum number of individuals to consider in each tournament.

    Returns:
        parents (list): A list of selected individuals.
    """

    indice_parents = []

    for i in range(len(population)):
        # Select a random tournament size between min_tournament_size and max_tournament_size
        tournament_size = np.random.randint(min_tournament_size, max_tournament_size + 1)

        # Select tournament_size individuals at random from the population
        tournament = random.sample(range(len(population)), tournament_size)

        # Determine the winner of the tournament (i.e., the individual with the highest fitness value)
        winner = tournament[0]
        for j in range(1, tournament_size):
            if fitness_values[tournament[j]] > fitness_values[winner]:
                winner = tournament[j]

        # Add the winner to the list of parents
        indice_parents.append(winner)

    return indice_parents


def crossover(parent1, parent2, productivity_map, proximity_map, cost_map, budget, generation):
    """
    This function takes in two parent solutions and returns child generated by crossover.

    Parameters:
        parent1 (numpy.ndarray): A numpy array representing the first parent solution.
        parent2 (numpy.ndarray): A numpy array representing the second parent solution.
        cost_map (numpy.ndarray): A numpy array representing the cost of each cell in the map.
        proximity_map (numpy.ndarray): A numpy array representing the proximity of each cell in the map.
        productivity_map (numpy.ndarray): A numpy array representing the productivity of each cell in the map.
        budget (float): The maximum budget for the solution.

    Returns:
        children (list): A list containing four numpy arrays representing the child solutions generated by crossover.
    """

    subgroup_coords1, _ = subgroups(parent1.copy())
    subgroup_coords2, _ = subgroups(parent2.copy())

    compactness1 = calculate_compactness(subgroup_coords1)
    compactness2 = calculate_compactness(subgroup_coords2)
    compactness_total = compactness1 + compactness2
    subgroup_coords_total = subgroup_coords1 + subgroup_coords2

    # Sort the subgroups by compactness in decreasing order
    sorted_subgroups = [subgroup for _, subgroup in sorted(zip(compactness_total, subgroup_coords_total), reverse=True)]

    # Child 1: Combine subgroups based on compactness
    child1 = np.zeros_like(parent1)
    child1_cost = 0
    for subgroup in sorted_subgroups:
        for coord in subgroup:
            if child1_cost + cost_map[coord] <= budget:
                if child1[coord] == 0:
                    child1[coord] = parent1[coord] if subgroup in subgroup_coords1 else parent2[coord]
                    child1_cost += cost_map[coord]
            else:
                break
    

    proximity1 = calculate_pro(subgroup_coords1, proximity_map)
    proximity2 = calculate_pro(subgroup_coords2, proximity_map)
    proximity_total = proximity1 + proximity2
    subgroup_coords_total = subgroup_coords1 + subgroup_coords2

    # Sort the subgroups by proxity in decreasing order
    sorted_subgroups = [subgroup for _, subgroup in sorted(zip(proximity_total, subgroup_coords_total))]

    # Child 2: Combine subgroups based on proxity
    child2 = np.zeros_like(parent1)
    child2_cost = 0
    for subgroup in sorted_subgroups:
        for coord in subgroup:
            if child2_cost + cost_map[coord] <= budget:
                if child2[coord] == 0:
                    child2[coord] = parent1[coord] if subgroup in subgroup_coords1 else parent2[coord]
                    child2_cost += cost_map[coord]
            else:
                break
    
    
    productivity1 = calculate_pro(subgroup_coords1, productivity_map)
    productivity2 = calculate_pro(subgroup_coords2, productivity_map)
    productivity_total = productivity1 + productivity2
    subgroup_coords_total = subgroup_coords1 + subgroup_coords2

    # Sort the subgroups by productivity in decreasing order
    sorted_subgroups = [subgroup for _, subgroup in sorted(zip(productivity_total, subgroup_coords_total), reverse=True)]

    # Child 1: Combine subgroups based on productivity
    child3 = np.zeros_like(parent1)
    child3_cost = 0
    for subgroup in sorted_subgroups:
        for coord in subgroup:
            if child3_cost + cost_map[coord] <= budget:
                if child3[coord] == 0:
                    child3[coord] = parent1[coord] if subgroup in subgroup_coords1 else parent2[coord]
                    child3_cost += cost_map[coord]
            else:
                break

    """
    if generation == 2:
        print(generation)
        fig, axs = plt.subplots(2, 3, figsize=(10, 8))

        # Plot parent 1
        axs[0, 0].imshow(parent1, cmap='coolwarm')
        axs[0, 0].set_title('Parent 1')

        # Plot parent 2
        axs[0, 1].imshow(parent2, cmap='coolwarm')
        axs[0, 1].set_title('Parent 2')

        # Plot child 1
        axs[1, 0].imshow(child1, cmap='coolwarm')
        axs[1, 0].set_title('compactness')

        # Plot child 2
        axs[1, 1].imshow(child2, cmap='coolwarm')
        axs[1, 1].set_title('proximity')

        # Plot child 2
        axs[1, 2].imshow(child3, cmap='coolwarm')
        axs[1, 2].set_title('productivity')

        plt.tight_layout()
        plt.show()
    """

    return child1, child2, child3


def mutate(individual, Decision_Map, mutation_prob, cost_map, budget):
    """
    This function mutates an individual by randomly changing a single cell value in the DecisionMap.

    Parameters:
        individual (numpy.ndarray): A numpy array representing the DecisionMap of an individual.
        mutation_prob (float): The probability of mutation.
        budget (float): The budget constraint.

    Returns:
        mutated_individual (numpy.ndarray): A numpy array representing the DecisionMap of the mutated individual.
    """
    mutate = False
    mutated_individual = individual.copy()
    if np.random.rand() < mutation_prob:
        i = np.random.randint(len(mutated_individual))
        j = np.random.randint(len(mutated_individual[0]))
        if Decision_Map[i, j] == 1:
            mutated_individual[i, j] = np.random.choice([0, 2])
            sum_cost = np.sum(cost_map[(mutated_individual == 2)])
            if sum_cost <= budget:
                mutated_individual[i, j] = 2
                mutate = True
        else:
            mutated_individual[i, j] = 0

    return mutated_individual


def replacement(parent_population, parent_fitness_values, offspring_population, offspring_fitness_values, population_size):
    """
    This function performs replacement to create the next generation of the population, using the parents and offspring.

    Parameters:
        parent_population (list of numpy.ndarrays): A list containing the parent solutions.
        parent_fitness_values (list of floats): A list containing the fitness values of the parent solutions.
        offspring_population (list of numpy.ndarrays): A list containing the offspring solutions.
        offspring_fitness_values (list of floats): A list containing the fitness values of the offspring solutions.
        population_size (int): The desired size of the new population.

    Returns:
        new_population (list of numpy.ndarrays): A list containing the new population of solutions.
        new_fitness_values (list of floats): A list containing the fitness values of the new population.
    """
    # Combine parent and offspring populations and their fitness values
    combined_population = parent_population + offspring_population
    combined_fitness_values = parent_fitness_values + offspring_fitness_values

    # Sort the combined population by fitness value in descending order
    sorted_indices = np.argsort(combined_fitness_values)[::-1]
    sorted_population = [combined_population[i] for i in sorted_indices]
    sorted_fitness_values = [combined_fitness_values[i] for i in sorted_indices]

    # Create the new population by selecting the top population_size solutions
    new_population = sorted_population[:population_size]
    new_fitness_values = sorted_fitness_values[:population_size]

    return new_population, new_fitness_values


def multi_objective_ga(Map, cost_map, productivity_map, proximity_map, budget=500, pop_size=50, num_generations=35, tournament_max_size=4, mutation_prob=0.1):
    
    if pop_size % 2 != 0:
        pop_size = pop_size + 1
    # Generate initial population
    population = generate_population(Map, cost_map, pop_size, budget)
    # Add best proximity and productivity solution

    # Evaluate fitness of each member of the population
    fitness_values = []

    for individu in population:
        subgroup_coords, _ = subgroups(individu.copy())
        fitness_values.append(calculate_fitness_globale(subgroup_coords, proximity_map, productivity_map))

    # Keep track of all solutions found
    all_solutions = []

    for i in range(num_generations):
        print("generation : ", i + 1)
        # Select parents using tournament selection
        parents_selected = tournament_selection(population, fitness_values, tournament_max_size)
        # Create new offspring through crossover
        offspring = []

        for j in range(0, pop_size, 2):

            parent1 = population[parents_selected[j]]
            parent2 = population[parents_selected[j + 1]]
            if np.array_equal(parent1, parent2):
                continue
            else:
                children = crossover(parent1, parent2, productivity_map, proximity_map, cost_map, budget, i)

                for child in children:
                    if np.all(child == 0):
                        continue
                    else:
                        if np.sum(cost_map[(child == 2)]) <= budget:
                            offspring.append(child)

        # Mutate some offspring
        for k in range(len(offspring)):
            mutated_individual = mutate(offspring[k], Map, mutation_prob, cost_map, budget)

            if np.sum(cost_map[(mutated_individual == 2)]) <= budget:
                offspring[k] = mutated_individual

        # Evaluate fitness of new offspring
        offspring_fitness_values = []
        for individu in offspring:
            subgroup_coords, _ = subgroups(individu.copy())
            offspring_fitness_values.append(calculate_fitness_globale(subgroup_coords, proximity_map, productivity_map))

        # Replace least fit individuals with offspring
        population, fitness_values = replacement(population, fitness_values, offspring, offspring_fitness_values, len(population))

        # Keep track of all solutions
        all_solutions.extend(population)

    return all_solutions
